// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/Bios-Marcel/cordless/tview"
	tcell "github.com/gdamore/tcell/v2"
)

type FakeApplicationInterface struct {
	DrawStub        func() *tview.Application
	drawMutex       sync.RWMutex
	drawArgsForCall []struct {
	}
	drawReturns struct {
		result1 *tview.Application
	}
	drawReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	ForceDrawStub        func() *tview.Application
	forceDrawMutex       sync.RWMutex
	forceDrawArgsForCall []struct {
	}
	forceDrawReturns struct {
		result1 *tview.Application
	}
	forceDrawReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	GetAfterDrawFuncStub        func() func(screen tcell.Screen)
	getAfterDrawFuncMutex       sync.RWMutex
	getAfterDrawFuncArgsForCall []struct {
	}
	getAfterDrawFuncReturns struct {
		result1 func(screen tcell.Screen)
	}
	getAfterDrawFuncReturnsOnCall map[int]struct {
		result1 func(screen tcell.Screen)
	}
	GetBeforeDrawFuncStub        func() func(screen tcell.Screen) bool
	getBeforeDrawFuncMutex       sync.RWMutex
	getBeforeDrawFuncArgsForCall []struct {
	}
	getBeforeDrawFuncReturns struct {
		result1 func(screen tcell.Screen) bool
	}
	getBeforeDrawFuncReturnsOnCall map[int]struct {
		result1 func(screen tcell.Screen) bool
	}
	GetComponentAtStub        func(int, int) *tview.Primitive
	getComponentAtMutex       sync.RWMutex
	getComponentAtArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getComponentAtReturns struct {
		result1 *tview.Primitive
	}
	getComponentAtReturnsOnCall map[int]struct {
		result1 *tview.Primitive
	}
	GetFocusStub        func() tview.Primitive
	getFocusMutex       sync.RWMutex
	getFocusArgsForCall []struct {
	}
	getFocusReturns struct {
		result1 tview.Primitive
	}
	getFocusReturnsOnCall map[int]struct {
		result1 tview.Primitive
	}
	GetInputCaptureStub        func() func(event *tcell.EventKey) *tcell.EventKey
	getInputCaptureMutex       sync.RWMutex
	getInputCaptureArgsForCall []struct {
	}
	getInputCaptureReturns struct {
		result1 func(event *tcell.EventKey) *tcell.EventKey
	}
	getInputCaptureReturnsOnCall map[int]struct {
		result1 func(event *tcell.EventKey) *tcell.EventKey
	}
	GetRootStub        func() tview.Primitive
	getRootMutex       sync.RWMutex
	getRootArgsForCall []struct {
	}
	getRootReturns struct {
		result1 tview.Primitive
	}
	getRootReturnsOnCall map[int]struct {
		result1 tview.Primitive
	}
	QueueEventStub        func(tcell.Event) *tview.Application
	queueEventMutex       sync.RWMutex
	queueEventArgsForCall []struct {
		arg1 tcell.Event
	}
	queueEventReturns struct {
		result1 *tview.Application
	}
	queueEventReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	QueueUpdateStub        func(func()) *tview.Application
	queueUpdateMutex       sync.RWMutex
	queueUpdateArgsForCall []struct {
		arg1 func()
	}
	queueUpdateReturns struct {
		result1 *tview.Application
	}
	queueUpdateReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	QueueUpdateDrawStub        func(func()) *tview.Application
	queueUpdateDrawMutex       sync.RWMutex
	queueUpdateDrawArgsForCall []struct {
		arg1 func()
	}
	queueUpdateDrawReturns struct {
		result1 *tview.Application
	}
	queueUpdateDrawReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	ResizeToFullScreenStub        func(tview.Primitive) *tview.Application
	resizeToFullScreenMutex       sync.RWMutex
	resizeToFullScreenArgsForCall []struct {
		arg1 tview.Primitive
	}
	resizeToFullScreenReturns struct {
		result1 *tview.Application
	}
	resizeToFullScreenReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	RunStub        func() error
	runMutex       sync.RWMutex
	runArgsForCall []struct {
	}
	runReturns struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	SetAfterDrawFuncStub        func(func(screen tcell.Screen)) *tview.Application
	setAfterDrawFuncMutex       sync.RWMutex
	setAfterDrawFuncArgsForCall []struct {
		arg1 func(screen tcell.Screen)
	}
	setAfterDrawFuncReturns struct {
		result1 *tview.Application
	}
	setAfterDrawFuncReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	SetBeforeDrawFuncStub        func(func(screen tcell.Screen) bool) *tview.Application
	setBeforeDrawFuncMutex       sync.RWMutex
	setBeforeDrawFuncArgsForCall []struct {
		arg1 func(screen tcell.Screen) bool
	}
	setBeforeDrawFuncReturns struct {
		result1 *tview.Application
	}
	setBeforeDrawFuncReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	SetFocusStub        func(tview.Primitive) *tview.Application
	setFocusMutex       sync.RWMutex
	setFocusArgsForCall []struct {
		arg1 tview.Primitive
	}
	setFocusReturns struct {
		result1 *tview.Application
	}
	setFocusReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	SetInputCaptureStub        func(func(event *tcell.EventKey) *tcell.EventKey) *tview.Application
	setInputCaptureMutex       sync.RWMutex
	setInputCaptureArgsForCall []struct {
		arg1 func(event *tcell.EventKey) *tcell.EventKey
	}
	setInputCaptureReturns struct {
		result1 *tview.Application
	}
	setInputCaptureReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	SetRootStub        func(tview.Primitive, bool) *tview.Application
	setRootMutex       sync.RWMutex
	setRootArgsForCall []struct {
		arg1 tview.Primitive
		arg2 bool
	}
	setRootReturns struct {
		result1 *tview.Application
	}
	setRootReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	SetScreenStub        func(tcell.Screen) *tview.Application
	setScreenMutex       sync.RWMutex
	setScreenArgsForCall []struct {
		arg1 tcell.Screen
	}
	setScreenReturns struct {
		result1 *tview.Application
	}
	setScreenReturnsOnCall map[int]struct {
		result1 *tview.Application
	}
	StopStub        func()
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
	}
	SuspendStub        func(func()) bool
	suspendMutex       sync.RWMutex
	suspendArgsForCall []struct {
		arg1 func()
	}
	suspendReturns struct {
		result1 bool
	}
	suspendReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeApplicationInterface) Draw() *tview.Application {
	fake.drawMutex.Lock()
	ret, specificReturn := fake.drawReturnsOnCall[len(fake.drawArgsForCall)]
	fake.drawArgsForCall = append(fake.drawArgsForCall, struct {
	}{})
	stub := fake.DrawStub
	fakeReturns := fake.drawReturns
	fake.recordInvocation("Draw", []interface{}{})
	fake.drawMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) DrawCallCount() int {
	fake.drawMutex.RLock()
	defer fake.drawMutex.RUnlock()
	return len(fake.drawArgsForCall)
}

func (fake *FakeApplicationInterface) DrawCalls(stub func() *tview.Application) {
	fake.drawMutex.Lock()
	defer fake.drawMutex.Unlock()
	fake.DrawStub = stub
}

func (fake *FakeApplicationInterface) DrawReturns(result1 *tview.Application) {
	fake.drawMutex.Lock()
	defer fake.drawMutex.Unlock()
	fake.DrawStub = nil
	fake.drawReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) DrawReturnsOnCall(i int, result1 *tview.Application) {
	fake.drawMutex.Lock()
	defer fake.drawMutex.Unlock()
	fake.DrawStub = nil
	if fake.drawReturnsOnCall == nil {
		fake.drawReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.drawReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) ForceDraw() *tview.Application {
	fake.forceDrawMutex.Lock()
	ret, specificReturn := fake.forceDrawReturnsOnCall[len(fake.forceDrawArgsForCall)]
	fake.forceDrawArgsForCall = append(fake.forceDrawArgsForCall, struct {
	}{})
	stub := fake.ForceDrawStub
	fakeReturns := fake.forceDrawReturns
	fake.recordInvocation("ForceDraw", []interface{}{})
	fake.forceDrawMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) ForceDrawCallCount() int {
	fake.forceDrawMutex.RLock()
	defer fake.forceDrawMutex.RUnlock()
	return len(fake.forceDrawArgsForCall)
}

func (fake *FakeApplicationInterface) ForceDrawCalls(stub func() *tview.Application) {
	fake.forceDrawMutex.Lock()
	defer fake.forceDrawMutex.Unlock()
	fake.ForceDrawStub = stub
}

func (fake *FakeApplicationInterface) ForceDrawReturns(result1 *tview.Application) {
	fake.forceDrawMutex.Lock()
	defer fake.forceDrawMutex.Unlock()
	fake.ForceDrawStub = nil
	fake.forceDrawReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) ForceDrawReturnsOnCall(i int, result1 *tview.Application) {
	fake.forceDrawMutex.Lock()
	defer fake.forceDrawMutex.Unlock()
	fake.ForceDrawStub = nil
	if fake.forceDrawReturnsOnCall == nil {
		fake.forceDrawReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.forceDrawReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) GetAfterDrawFunc() func(screen tcell.Screen) {
	fake.getAfterDrawFuncMutex.Lock()
	ret, specificReturn := fake.getAfterDrawFuncReturnsOnCall[len(fake.getAfterDrawFuncArgsForCall)]
	fake.getAfterDrawFuncArgsForCall = append(fake.getAfterDrawFuncArgsForCall, struct {
	}{})
	stub := fake.GetAfterDrawFuncStub
	fakeReturns := fake.getAfterDrawFuncReturns
	fake.recordInvocation("GetAfterDrawFunc", []interface{}{})
	fake.getAfterDrawFuncMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) GetAfterDrawFuncCallCount() int {
	fake.getAfterDrawFuncMutex.RLock()
	defer fake.getAfterDrawFuncMutex.RUnlock()
	return len(fake.getAfterDrawFuncArgsForCall)
}

func (fake *FakeApplicationInterface) GetAfterDrawFuncCalls(stub func() func(screen tcell.Screen)) {
	fake.getAfterDrawFuncMutex.Lock()
	defer fake.getAfterDrawFuncMutex.Unlock()
	fake.GetAfterDrawFuncStub = stub
}

func (fake *FakeApplicationInterface) GetAfterDrawFuncReturns(result1 func(screen tcell.Screen)) {
	fake.getAfterDrawFuncMutex.Lock()
	defer fake.getAfterDrawFuncMutex.Unlock()
	fake.GetAfterDrawFuncStub = nil
	fake.getAfterDrawFuncReturns = struct {
		result1 func(screen tcell.Screen)
	}{result1}
}

func (fake *FakeApplicationInterface) GetAfterDrawFuncReturnsOnCall(i int, result1 func(screen tcell.Screen)) {
	fake.getAfterDrawFuncMutex.Lock()
	defer fake.getAfterDrawFuncMutex.Unlock()
	fake.GetAfterDrawFuncStub = nil
	if fake.getAfterDrawFuncReturnsOnCall == nil {
		fake.getAfterDrawFuncReturnsOnCall = make(map[int]struct {
			result1 func(screen tcell.Screen)
		})
	}
	fake.getAfterDrawFuncReturnsOnCall[i] = struct {
		result1 func(screen tcell.Screen)
	}{result1}
}

func (fake *FakeApplicationInterface) GetBeforeDrawFunc() func(screen tcell.Screen) bool {
	fake.getBeforeDrawFuncMutex.Lock()
	ret, specificReturn := fake.getBeforeDrawFuncReturnsOnCall[len(fake.getBeforeDrawFuncArgsForCall)]
	fake.getBeforeDrawFuncArgsForCall = append(fake.getBeforeDrawFuncArgsForCall, struct {
	}{})
	stub := fake.GetBeforeDrawFuncStub
	fakeReturns := fake.getBeforeDrawFuncReturns
	fake.recordInvocation("GetBeforeDrawFunc", []interface{}{})
	fake.getBeforeDrawFuncMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) GetBeforeDrawFuncCallCount() int {
	fake.getBeforeDrawFuncMutex.RLock()
	defer fake.getBeforeDrawFuncMutex.RUnlock()
	return len(fake.getBeforeDrawFuncArgsForCall)
}

func (fake *FakeApplicationInterface) GetBeforeDrawFuncCalls(stub func() func(screen tcell.Screen) bool) {
	fake.getBeforeDrawFuncMutex.Lock()
	defer fake.getBeforeDrawFuncMutex.Unlock()
	fake.GetBeforeDrawFuncStub = stub
}

func (fake *FakeApplicationInterface) GetBeforeDrawFuncReturns(result1 func(screen tcell.Screen) bool) {
	fake.getBeforeDrawFuncMutex.Lock()
	defer fake.getBeforeDrawFuncMutex.Unlock()
	fake.GetBeforeDrawFuncStub = nil
	fake.getBeforeDrawFuncReturns = struct {
		result1 func(screen tcell.Screen) bool
	}{result1}
}

func (fake *FakeApplicationInterface) GetBeforeDrawFuncReturnsOnCall(i int, result1 func(screen tcell.Screen) bool) {
	fake.getBeforeDrawFuncMutex.Lock()
	defer fake.getBeforeDrawFuncMutex.Unlock()
	fake.GetBeforeDrawFuncStub = nil
	if fake.getBeforeDrawFuncReturnsOnCall == nil {
		fake.getBeforeDrawFuncReturnsOnCall = make(map[int]struct {
			result1 func(screen tcell.Screen) bool
		})
	}
	fake.getBeforeDrawFuncReturnsOnCall[i] = struct {
		result1 func(screen tcell.Screen) bool
	}{result1}
}

func (fake *FakeApplicationInterface) GetComponentAt(arg1 int, arg2 int) *tview.Primitive {
	fake.getComponentAtMutex.Lock()
	ret, specificReturn := fake.getComponentAtReturnsOnCall[len(fake.getComponentAtArgsForCall)]
	fake.getComponentAtArgsForCall = append(fake.getComponentAtArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.GetComponentAtStub
	fakeReturns := fake.getComponentAtReturns
	fake.recordInvocation("GetComponentAt", []interface{}{arg1, arg2})
	fake.getComponentAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) GetComponentAtCallCount() int {
	fake.getComponentAtMutex.RLock()
	defer fake.getComponentAtMutex.RUnlock()
	return len(fake.getComponentAtArgsForCall)
}

func (fake *FakeApplicationInterface) GetComponentAtCalls(stub func(int, int) *tview.Primitive) {
	fake.getComponentAtMutex.Lock()
	defer fake.getComponentAtMutex.Unlock()
	fake.GetComponentAtStub = stub
}

func (fake *FakeApplicationInterface) GetComponentAtArgsForCall(i int) (int, int) {
	fake.getComponentAtMutex.RLock()
	defer fake.getComponentAtMutex.RUnlock()
	argsForCall := fake.getComponentAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationInterface) GetComponentAtReturns(result1 *tview.Primitive) {
	fake.getComponentAtMutex.Lock()
	defer fake.getComponentAtMutex.Unlock()
	fake.GetComponentAtStub = nil
	fake.getComponentAtReturns = struct {
		result1 *tview.Primitive
	}{result1}
}

func (fake *FakeApplicationInterface) GetComponentAtReturnsOnCall(i int, result1 *tview.Primitive) {
	fake.getComponentAtMutex.Lock()
	defer fake.getComponentAtMutex.Unlock()
	fake.GetComponentAtStub = nil
	if fake.getComponentAtReturnsOnCall == nil {
		fake.getComponentAtReturnsOnCall = make(map[int]struct {
			result1 *tview.Primitive
		})
	}
	fake.getComponentAtReturnsOnCall[i] = struct {
		result1 *tview.Primitive
	}{result1}
}

func (fake *FakeApplicationInterface) GetFocus() tview.Primitive {
	fake.getFocusMutex.Lock()
	ret, specificReturn := fake.getFocusReturnsOnCall[len(fake.getFocusArgsForCall)]
	fake.getFocusArgsForCall = append(fake.getFocusArgsForCall, struct {
	}{})
	stub := fake.GetFocusStub
	fakeReturns := fake.getFocusReturns
	fake.recordInvocation("GetFocus", []interface{}{})
	fake.getFocusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) GetFocusCallCount() int {
	fake.getFocusMutex.RLock()
	defer fake.getFocusMutex.RUnlock()
	return len(fake.getFocusArgsForCall)
}

func (fake *FakeApplicationInterface) GetFocusCalls(stub func() tview.Primitive) {
	fake.getFocusMutex.Lock()
	defer fake.getFocusMutex.Unlock()
	fake.GetFocusStub = stub
}

func (fake *FakeApplicationInterface) GetFocusReturns(result1 tview.Primitive) {
	fake.getFocusMutex.Lock()
	defer fake.getFocusMutex.Unlock()
	fake.GetFocusStub = nil
	fake.getFocusReturns = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeApplicationInterface) GetFocusReturnsOnCall(i int, result1 tview.Primitive) {
	fake.getFocusMutex.Lock()
	defer fake.getFocusMutex.Unlock()
	fake.GetFocusStub = nil
	if fake.getFocusReturnsOnCall == nil {
		fake.getFocusReturnsOnCall = make(map[int]struct {
			result1 tview.Primitive
		})
	}
	fake.getFocusReturnsOnCall[i] = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeApplicationInterface) GetInputCapture() func(event *tcell.EventKey) *tcell.EventKey {
	fake.getInputCaptureMutex.Lock()
	ret, specificReturn := fake.getInputCaptureReturnsOnCall[len(fake.getInputCaptureArgsForCall)]
	fake.getInputCaptureArgsForCall = append(fake.getInputCaptureArgsForCall, struct {
	}{})
	stub := fake.GetInputCaptureStub
	fakeReturns := fake.getInputCaptureReturns
	fake.recordInvocation("GetInputCapture", []interface{}{})
	fake.getInputCaptureMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) GetInputCaptureCallCount() int {
	fake.getInputCaptureMutex.RLock()
	defer fake.getInputCaptureMutex.RUnlock()
	return len(fake.getInputCaptureArgsForCall)
}

func (fake *FakeApplicationInterface) GetInputCaptureCalls(stub func() func(event *tcell.EventKey) *tcell.EventKey) {
	fake.getInputCaptureMutex.Lock()
	defer fake.getInputCaptureMutex.Unlock()
	fake.GetInputCaptureStub = stub
}

func (fake *FakeApplicationInterface) GetInputCaptureReturns(result1 func(event *tcell.EventKey) *tcell.EventKey) {
	fake.getInputCaptureMutex.Lock()
	defer fake.getInputCaptureMutex.Unlock()
	fake.GetInputCaptureStub = nil
	fake.getInputCaptureReturns = struct {
		result1 func(event *tcell.EventKey) *tcell.EventKey
	}{result1}
}

func (fake *FakeApplicationInterface) GetInputCaptureReturnsOnCall(i int, result1 func(event *tcell.EventKey) *tcell.EventKey) {
	fake.getInputCaptureMutex.Lock()
	defer fake.getInputCaptureMutex.Unlock()
	fake.GetInputCaptureStub = nil
	if fake.getInputCaptureReturnsOnCall == nil {
		fake.getInputCaptureReturnsOnCall = make(map[int]struct {
			result1 func(event *tcell.EventKey) *tcell.EventKey
		})
	}
	fake.getInputCaptureReturnsOnCall[i] = struct {
		result1 func(event *tcell.EventKey) *tcell.EventKey
	}{result1}
}

func (fake *FakeApplicationInterface) GetRoot() tview.Primitive {
	fake.getRootMutex.Lock()
	ret, specificReturn := fake.getRootReturnsOnCall[len(fake.getRootArgsForCall)]
	fake.getRootArgsForCall = append(fake.getRootArgsForCall, struct {
	}{})
	stub := fake.GetRootStub
	fakeReturns := fake.getRootReturns
	fake.recordInvocation("GetRoot", []interface{}{})
	fake.getRootMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) GetRootCallCount() int {
	fake.getRootMutex.RLock()
	defer fake.getRootMutex.RUnlock()
	return len(fake.getRootArgsForCall)
}

func (fake *FakeApplicationInterface) GetRootCalls(stub func() tview.Primitive) {
	fake.getRootMutex.Lock()
	defer fake.getRootMutex.Unlock()
	fake.GetRootStub = stub
}

func (fake *FakeApplicationInterface) GetRootReturns(result1 tview.Primitive) {
	fake.getRootMutex.Lock()
	defer fake.getRootMutex.Unlock()
	fake.GetRootStub = nil
	fake.getRootReturns = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeApplicationInterface) GetRootReturnsOnCall(i int, result1 tview.Primitive) {
	fake.getRootMutex.Lock()
	defer fake.getRootMutex.Unlock()
	fake.GetRootStub = nil
	if fake.getRootReturnsOnCall == nil {
		fake.getRootReturnsOnCall = make(map[int]struct {
			result1 tview.Primitive
		})
	}
	fake.getRootReturnsOnCall[i] = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeApplicationInterface) QueueEvent(arg1 tcell.Event) *tview.Application {
	fake.queueEventMutex.Lock()
	ret, specificReturn := fake.queueEventReturnsOnCall[len(fake.queueEventArgsForCall)]
	fake.queueEventArgsForCall = append(fake.queueEventArgsForCall, struct {
		arg1 tcell.Event
	}{arg1})
	stub := fake.QueueEventStub
	fakeReturns := fake.queueEventReturns
	fake.recordInvocation("QueueEvent", []interface{}{arg1})
	fake.queueEventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) QueueEventCallCount() int {
	fake.queueEventMutex.RLock()
	defer fake.queueEventMutex.RUnlock()
	return len(fake.queueEventArgsForCall)
}

func (fake *FakeApplicationInterface) QueueEventCalls(stub func(tcell.Event) *tview.Application) {
	fake.queueEventMutex.Lock()
	defer fake.queueEventMutex.Unlock()
	fake.QueueEventStub = stub
}

func (fake *FakeApplicationInterface) QueueEventArgsForCall(i int) tcell.Event {
	fake.queueEventMutex.RLock()
	defer fake.queueEventMutex.RUnlock()
	argsForCall := fake.queueEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) QueueEventReturns(result1 *tview.Application) {
	fake.queueEventMutex.Lock()
	defer fake.queueEventMutex.Unlock()
	fake.QueueEventStub = nil
	fake.queueEventReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) QueueEventReturnsOnCall(i int, result1 *tview.Application) {
	fake.queueEventMutex.Lock()
	defer fake.queueEventMutex.Unlock()
	fake.QueueEventStub = nil
	if fake.queueEventReturnsOnCall == nil {
		fake.queueEventReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.queueEventReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) QueueUpdate(arg1 func()) *tview.Application {
	fake.queueUpdateMutex.Lock()
	ret, specificReturn := fake.queueUpdateReturnsOnCall[len(fake.queueUpdateArgsForCall)]
	fake.queueUpdateArgsForCall = append(fake.queueUpdateArgsForCall, struct {
		arg1 func()
	}{arg1})
	stub := fake.QueueUpdateStub
	fakeReturns := fake.queueUpdateReturns
	fake.recordInvocation("QueueUpdate", []interface{}{arg1})
	fake.queueUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) QueueUpdateCallCount() int {
	fake.queueUpdateMutex.RLock()
	defer fake.queueUpdateMutex.RUnlock()
	return len(fake.queueUpdateArgsForCall)
}

func (fake *FakeApplicationInterface) QueueUpdateCalls(stub func(func()) *tview.Application) {
	fake.queueUpdateMutex.Lock()
	defer fake.queueUpdateMutex.Unlock()
	fake.QueueUpdateStub = stub
}

func (fake *FakeApplicationInterface) QueueUpdateArgsForCall(i int) func() {
	fake.queueUpdateMutex.RLock()
	defer fake.queueUpdateMutex.RUnlock()
	argsForCall := fake.queueUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) QueueUpdateReturns(result1 *tview.Application) {
	fake.queueUpdateMutex.Lock()
	defer fake.queueUpdateMutex.Unlock()
	fake.QueueUpdateStub = nil
	fake.queueUpdateReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) QueueUpdateReturnsOnCall(i int, result1 *tview.Application) {
	fake.queueUpdateMutex.Lock()
	defer fake.queueUpdateMutex.Unlock()
	fake.QueueUpdateStub = nil
	if fake.queueUpdateReturnsOnCall == nil {
		fake.queueUpdateReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.queueUpdateReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) QueueUpdateDraw(arg1 func()) *tview.Application {
	fake.queueUpdateDrawMutex.Lock()
	ret, specificReturn := fake.queueUpdateDrawReturnsOnCall[len(fake.queueUpdateDrawArgsForCall)]
	fake.queueUpdateDrawArgsForCall = append(fake.queueUpdateDrawArgsForCall, struct {
		arg1 func()
	}{arg1})
	stub := fake.QueueUpdateDrawStub
	fakeReturns := fake.queueUpdateDrawReturns
	fake.recordInvocation("QueueUpdateDraw", []interface{}{arg1})
	fake.queueUpdateDrawMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) QueueUpdateDrawCallCount() int {
	fake.queueUpdateDrawMutex.RLock()
	defer fake.queueUpdateDrawMutex.RUnlock()
	return len(fake.queueUpdateDrawArgsForCall)
}

func (fake *FakeApplicationInterface) QueueUpdateDrawCalls(stub func(func()) *tview.Application) {
	fake.queueUpdateDrawMutex.Lock()
	defer fake.queueUpdateDrawMutex.Unlock()
	fake.QueueUpdateDrawStub = stub
}

func (fake *FakeApplicationInterface) QueueUpdateDrawArgsForCall(i int) func() {
	fake.queueUpdateDrawMutex.RLock()
	defer fake.queueUpdateDrawMutex.RUnlock()
	argsForCall := fake.queueUpdateDrawArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) QueueUpdateDrawReturns(result1 *tview.Application) {
	fake.queueUpdateDrawMutex.Lock()
	defer fake.queueUpdateDrawMutex.Unlock()
	fake.QueueUpdateDrawStub = nil
	fake.queueUpdateDrawReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) QueueUpdateDrawReturnsOnCall(i int, result1 *tview.Application) {
	fake.queueUpdateDrawMutex.Lock()
	defer fake.queueUpdateDrawMutex.Unlock()
	fake.QueueUpdateDrawStub = nil
	if fake.queueUpdateDrawReturnsOnCall == nil {
		fake.queueUpdateDrawReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.queueUpdateDrawReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) ResizeToFullScreen(arg1 tview.Primitive) *tview.Application {
	fake.resizeToFullScreenMutex.Lock()
	ret, specificReturn := fake.resizeToFullScreenReturnsOnCall[len(fake.resizeToFullScreenArgsForCall)]
	fake.resizeToFullScreenArgsForCall = append(fake.resizeToFullScreenArgsForCall, struct {
		arg1 tview.Primitive
	}{arg1})
	stub := fake.ResizeToFullScreenStub
	fakeReturns := fake.resizeToFullScreenReturns
	fake.recordInvocation("ResizeToFullScreen", []interface{}{arg1})
	fake.resizeToFullScreenMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) ResizeToFullScreenCallCount() int {
	fake.resizeToFullScreenMutex.RLock()
	defer fake.resizeToFullScreenMutex.RUnlock()
	return len(fake.resizeToFullScreenArgsForCall)
}

func (fake *FakeApplicationInterface) ResizeToFullScreenCalls(stub func(tview.Primitive) *tview.Application) {
	fake.resizeToFullScreenMutex.Lock()
	defer fake.resizeToFullScreenMutex.Unlock()
	fake.ResizeToFullScreenStub = stub
}

func (fake *FakeApplicationInterface) ResizeToFullScreenArgsForCall(i int) tview.Primitive {
	fake.resizeToFullScreenMutex.RLock()
	defer fake.resizeToFullScreenMutex.RUnlock()
	argsForCall := fake.resizeToFullScreenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) ResizeToFullScreenReturns(result1 *tview.Application) {
	fake.resizeToFullScreenMutex.Lock()
	defer fake.resizeToFullScreenMutex.Unlock()
	fake.ResizeToFullScreenStub = nil
	fake.resizeToFullScreenReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) ResizeToFullScreenReturnsOnCall(i int, result1 *tview.Application) {
	fake.resizeToFullScreenMutex.Lock()
	defer fake.resizeToFullScreenMutex.Unlock()
	fake.ResizeToFullScreenStub = nil
	if fake.resizeToFullScreenReturnsOnCall == nil {
		fake.resizeToFullScreenReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.resizeToFullScreenReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) Run() error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
	}{})
	stub := fake.RunStub
	fakeReturns := fake.runReturns
	fake.recordInvocation("Run", []interface{}{})
	fake.runMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeApplicationInterface) RunCalls(stub func() error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeApplicationInterface) RunReturns(result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationInterface) RunReturnsOnCall(i int, result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationInterface) SetAfterDrawFunc(arg1 func(screen tcell.Screen)) *tview.Application {
	fake.setAfterDrawFuncMutex.Lock()
	ret, specificReturn := fake.setAfterDrawFuncReturnsOnCall[len(fake.setAfterDrawFuncArgsForCall)]
	fake.setAfterDrawFuncArgsForCall = append(fake.setAfterDrawFuncArgsForCall, struct {
		arg1 func(screen tcell.Screen)
	}{arg1})
	stub := fake.SetAfterDrawFuncStub
	fakeReturns := fake.setAfterDrawFuncReturns
	fake.recordInvocation("SetAfterDrawFunc", []interface{}{arg1})
	fake.setAfterDrawFuncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) SetAfterDrawFuncCallCount() int {
	fake.setAfterDrawFuncMutex.RLock()
	defer fake.setAfterDrawFuncMutex.RUnlock()
	return len(fake.setAfterDrawFuncArgsForCall)
}

func (fake *FakeApplicationInterface) SetAfterDrawFuncCalls(stub func(func(screen tcell.Screen)) *tview.Application) {
	fake.setAfterDrawFuncMutex.Lock()
	defer fake.setAfterDrawFuncMutex.Unlock()
	fake.SetAfterDrawFuncStub = stub
}

func (fake *FakeApplicationInterface) SetAfterDrawFuncArgsForCall(i int) func(screen tcell.Screen) {
	fake.setAfterDrawFuncMutex.RLock()
	defer fake.setAfterDrawFuncMutex.RUnlock()
	argsForCall := fake.setAfterDrawFuncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) SetAfterDrawFuncReturns(result1 *tview.Application) {
	fake.setAfterDrawFuncMutex.Lock()
	defer fake.setAfterDrawFuncMutex.Unlock()
	fake.SetAfterDrawFuncStub = nil
	fake.setAfterDrawFuncReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetAfterDrawFuncReturnsOnCall(i int, result1 *tview.Application) {
	fake.setAfterDrawFuncMutex.Lock()
	defer fake.setAfterDrawFuncMutex.Unlock()
	fake.SetAfterDrawFuncStub = nil
	if fake.setAfterDrawFuncReturnsOnCall == nil {
		fake.setAfterDrawFuncReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.setAfterDrawFuncReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetBeforeDrawFunc(arg1 func(screen tcell.Screen) bool) *tview.Application {
	fake.setBeforeDrawFuncMutex.Lock()
	ret, specificReturn := fake.setBeforeDrawFuncReturnsOnCall[len(fake.setBeforeDrawFuncArgsForCall)]
	fake.setBeforeDrawFuncArgsForCall = append(fake.setBeforeDrawFuncArgsForCall, struct {
		arg1 func(screen tcell.Screen) bool
	}{arg1})
	stub := fake.SetBeforeDrawFuncStub
	fakeReturns := fake.setBeforeDrawFuncReturns
	fake.recordInvocation("SetBeforeDrawFunc", []interface{}{arg1})
	fake.setBeforeDrawFuncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) SetBeforeDrawFuncCallCount() int {
	fake.setBeforeDrawFuncMutex.RLock()
	defer fake.setBeforeDrawFuncMutex.RUnlock()
	return len(fake.setBeforeDrawFuncArgsForCall)
}

func (fake *FakeApplicationInterface) SetBeforeDrawFuncCalls(stub func(func(screen tcell.Screen) bool) *tview.Application) {
	fake.setBeforeDrawFuncMutex.Lock()
	defer fake.setBeforeDrawFuncMutex.Unlock()
	fake.SetBeforeDrawFuncStub = stub
}

func (fake *FakeApplicationInterface) SetBeforeDrawFuncArgsForCall(i int) func(screen tcell.Screen) bool {
	fake.setBeforeDrawFuncMutex.RLock()
	defer fake.setBeforeDrawFuncMutex.RUnlock()
	argsForCall := fake.setBeforeDrawFuncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) SetBeforeDrawFuncReturns(result1 *tview.Application) {
	fake.setBeforeDrawFuncMutex.Lock()
	defer fake.setBeforeDrawFuncMutex.Unlock()
	fake.SetBeforeDrawFuncStub = nil
	fake.setBeforeDrawFuncReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetBeforeDrawFuncReturnsOnCall(i int, result1 *tview.Application) {
	fake.setBeforeDrawFuncMutex.Lock()
	defer fake.setBeforeDrawFuncMutex.Unlock()
	fake.SetBeforeDrawFuncStub = nil
	if fake.setBeforeDrawFuncReturnsOnCall == nil {
		fake.setBeforeDrawFuncReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.setBeforeDrawFuncReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetFocus(arg1 tview.Primitive) *tview.Application {
	fake.setFocusMutex.Lock()
	ret, specificReturn := fake.setFocusReturnsOnCall[len(fake.setFocusArgsForCall)]
	fake.setFocusArgsForCall = append(fake.setFocusArgsForCall, struct {
		arg1 tview.Primitive
	}{arg1})
	stub := fake.SetFocusStub
	fakeReturns := fake.setFocusReturns
	fake.recordInvocation("SetFocus", []interface{}{arg1})
	fake.setFocusMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) SetFocusCallCount() int {
	fake.setFocusMutex.RLock()
	defer fake.setFocusMutex.RUnlock()
	return len(fake.setFocusArgsForCall)
}

func (fake *FakeApplicationInterface) SetFocusCalls(stub func(tview.Primitive) *tview.Application) {
	fake.setFocusMutex.Lock()
	defer fake.setFocusMutex.Unlock()
	fake.SetFocusStub = stub
}

func (fake *FakeApplicationInterface) SetFocusArgsForCall(i int) tview.Primitive {
	fake.setFocusMutex.RLock()
	defer fake.setFocusMutex.RUnlock()
	argsForCall := fake.setFocusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) SetFocusReturns(result1 *tview.Application) {
	fake.setFocusMutex.Lock()
	defer fake.setFocusMutex.Unlock()
	fake.SetFocusStub = nil
	fake.setFocusReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetFocusReturnsOnCall(i int, result1 *tview.Application) {
	fake.setFocusMutex.Lock()
	defer fake.setFocusMutex.Unlock()
	fake.SetFocusStub = nil
	if fake.setFocusReturnsOnCall == nil {
		fake.setFocusReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.setFocusReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetInputCapture(arg1 func(event *tcell.EventKey) *tcell.EventKey) *tview.Application {
	fake.setInputCaptureMutex.Lock()
	ret, specificReturn := fake.setInputCaptureReturnsOnCall[len(fake.setInputCaptureArgsForCall)]
	fake.setInputCaptureArgsForCall = append(fake.setInputCaptureArgsForCall, struct {
		arg1 func(event *tcell.EventKey) *tcell.EventKey
	}{arg1})
	stub := fake.SetInputCaptureStub
	fakeReturns := fake.setInputCaptureReturns
	fake.recordInvocation("SetInputCapture", []interface{}{arg1})
	fake.setInputCaptureMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) SetInputCaptureCallCount() int {
	fake.setInputCaptureMutex.RLock()
	defer fake.setInputCaptureMutex.RUnlock()
	return len(fake.setInputCaptureArgsForCall)
}

func (fake *FakeApplicationInterface) SetInputCaptureCalls(stub func(func(event *tcell.EventKey) *tcell.EventKey) *tview.Application) {
	fake.setInputCaptureMutex.Lock()
	defer fake.setInputCaptureMutex.Unlock()
	fake.SetInputCaptureStub = stub
}

func (fake *FakeApplicationInterface) SetInputCaptureArgsForCall(i int) func(event *tcell.EventKey) *tcell.EventKey {
	fake.setInputCaptureMutex.RLock()
	defer fake.setInputCaptureMutex.RUnlock()
	argsForCall := fake.setInputCaptureArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) SetInputCaptureReturns(result1 *tview.Application) {
	fake.setInputCaptureMutex.Lock()
	defer fake.setInputCaptureMutex.Unlock()
	fake.SetInputCaptureStub = nil
	fake.setInputCaptureReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetInputCaptureReturnsOnCall(i int, result1 *tview.Application) {
	fake.setInputCaptureMutex.Lock()
	defer fake.setInputCaptureMutex.Unlock()
	fake.SetInputCaptureStub = nil
	if fake.setInputCaptureReturnsOnCall == nil {
		fake.setInputCaptureReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.setInputCaptureReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetRoot(arg1 tview.Primitive, arg2 bool) *tview.Application {
	fake.setRootMutex.Lock()
	ret, specificReturn := fake.setRootReturnsOnCall[len(fake.setRootArgsForCall)]
	fake.setRootArgsForCall = append(fake.setRootArgsForCall, struct {
		arg1 tview.Primitive
		arg2 bool
	}{arg1, arg2})
	stub := fake.SetRootStub
	fakeReturns := fake.setRootReturns
	fake.recordInvocation("SetRoot", []interface{}{arg1, arg2})
	fake.setRootMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) SetRootCallCount() int {
	fake.setRootMutex.RLock()
	defer fake.setRootMutex.RUnlock()
	return len(fake.setRootArgsForCall)
}

func (fake *FakeApplicationInterface) SetRootCalls(stub func(tview.Primitive, bool) *tview.Application) {
	fake.setRootMutex.Lock()
	defer fake.setRootMutex.Unlock()
	fake.SetRootStub = stub
}

func (fake *FakeApplicationInterface) SetRootArgsForCall(i int) (tview.Primitive, bool) {
	fake.setRootMutex.RLock()
	defer fake.setRootMutex.RUnlock()
	argsForCall := fake.setRootArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationInterface) SetRootReturns(result1 *tview.Application) {
	fake.setRootMutex.Lock()
	defer fake.setRootMutex.Unlock()
	fake.SetRootStub = nil
	fake.setRootReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetRootReturnsOnCall(i int, result1 *tview.Application) {
	fake.setRootMutex.Lock()
	defer fake.setRootMutex.Unlock()
	fake.SetRootStub = nil
	if fake.setRootReturnsOnCall == nil {
		fake.setRootReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.setRootReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetScreen(arg1 tcell.Screen) *tview.Application {
	fake.setScreenMutex.Lock()
	ret, specificReturn := fake.setScreenReturnsOnCall[len(fake.setScreenArgsForCall)]
	fake.setScreenArgsForCall = append(fake.setScreenArgsForCall, struct {
		arg1 tcell.Screen
	}{arg1})
	stub := fake.SetScreenStub
	fakeReturns := fake.setScreenReturns
	fake.recordInvocation("SetScreen", []interface{}{arg1})
	fake.setScreenMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) SetScreenCallCount() int {
	fake.setScreenMutex.RLock()
	defer fake.setScreenMutex.RUnlock()
	return len(fake.setScreenArgsForCall)
}

func (fake *FakeApplicationInterface) SetScreenCalls(stub func(tcell.Screen) *tview.Application) {
	fake.setScreenMutex.Lock()
	defer fake.setScreenMutex.Unlock()
	fake.SetScreenStub = stub
}

func (fake *FakeApplicationInterface) SetScreenArgsForCall(i int) tcell.Screen {
	fake.setScreenMutex.RLock()
	defer fake.setScreenMutex.RUnlock()
	argsForCall := fake.setScreenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) SetScreenReturns(result1 *tview.Application) {
	fake.setScreenMutex.Lock()
	defer fake.setScreenMutex.Unlock()
	fake.SetScreenStub = nil
	fake.setScreenReturns = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) SetScreenReturnsOnCall(i int, result1 *tview.Application) {
	fake.setScreenMutex.Lock()
	defer fake.setScreenMutex.Unlock()
	fake.SetScreenStub = nil
	if fake.setScreenReturnsOnCall == nil {
		fake.setScreenReturnsOnCall = make(map[int]struct {
			result1 *tview.Application
		})
	}
	fake.setScreenReturnsOnCall[i] = struct {
		result1 *tview.Application
	}{result1}
}

func (fake *FakeApplicationInterface) Stop() {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
	}{})
	stub := fake.StopStub
	fake.recordInvocation("Stop", []interface{}{})
	fake.stopMutex.Unlock()
	if stub != nil {
		fake.StopStub()
	}
}

func (fake *FakeApplicationInterface) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeApplicationInterface) StopCalls(stub func()) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeApplicationInterface) Suspend(arg1 func()) bool {
	fake.suspendMutex.Lock()
	ret, specificReturn := fake.suspendReturnsOnCall[len(fake.suspendArgsForCall)]
	fake.suspendArgsForCall = append(fake.suspendArgsForCall, struct {
		arg1 func()
	}{arg1})
	stub := fake.SuspendStub
	fakeReturns := fake.suspendReturns
	fake.recordInvocation("Suspend", []interface{}{arg1})
	fake.suspendMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationInterface) SuspendCallCount() int {
	fake.suspendMutex.RLock()
	defer fake.suspendMutex.RUnlock()
	return len(fake.suspendArgsForCall)
}

func (fake *FakeApplicationInterface) SuspendCalls(stub func(func()) bool) {
	fake.suspendMutex.Lock()
	defer fake.suspendMutex.Unlock()
	fake.SuspendStub = stub
}

func (fake *FakeApplicationInterface) SuspendArgsForCall(i int) func() {
	fake.suspendMutex.RLock()
	defer fake.suspendMutex.RUnlock()
	argsForCall := fake.suspendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationInterface) SuspendReturns(result1 bool) {
	fake.suspendMutex.Lock()
	defer fake.suspendMutex.Unlock()
	fake.SuspendStub = nil
	fake.suspendReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeApplicationInterface) SuspendReturnsOnCall(i int, result1 bool) {
	fake.suspendMutex.Lock()
	defer fake.suspendMutex.Unlock()
	fake.SuspendStub = nil
	if fake.suspendReturnsOnCall == nil {
		fake.suspendReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.suspendReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeApplicationInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.drawMutex.RLock()
	defer fake.drawMutex.RUnlock()
	fake.forceDrawMutex.RLock()
	defer fake.forceDrawMutex.RUnlock()
	fake.getAfterDrawFuncMutex.RLock()
	defer fake.getAfterDrawFuncMutex.RUnlock()
	fake.getBeforeDrawFuncMutex.RLock()
	defer fake.getBeforeDrawFuncMutex.RUnlock()
	fake.getComponentAtMutex.RLock()
	defer fake.getComponentAtMutex.RUnlock()
	fake.getFocusMutex.RLock()
	defer fake.getFocusMutex.RUnlock()
	fake.getInputCaptureMutex.RLock()
	defer fake.getInputCaptureMutex.RUnlock()
	fake.getRootMutex.RLock()
	defer fake.getRootMutex.RUnlock()
	fake.queueEventMutex.RLock()
	defer fake.queueEventMutex.RUnlock()
	fake.queueUpdateMutex.RLock()
	defer fake.queueUpdateMutex.RUnlock()
	fake.queueUpdateDrawMutex.RLock()
	defer fake.queueUpdateDrawMutex.RUnlock()
	fake.resizeToFullScreenMutex.RLock()
	defer fake.resizeToFullScreenMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.setAfterDrawFuncMutex.RLock()
	defer fake.setAfterDrawFuncMutex.RUnlock()
	fake.setBeforeDrawFuncMutex.RLock()
	defer fake.setBeforeDrawFuncMutex.RUnlock()
	fake.setFocusMutex.RLock()
	defer fake.setFocusMutex.RUnlock()
	fake.setInputCaptureMutex.RLock()
	defer fake.setInputCaptureMutex.RUnlock()
	fake.setRootMutex.RLock()
	defer fake.setRootMutex.RUnlock()
	fake.setScreenMutex.RLock()
	defer fake.setScreenMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.suspendMutex.RLock()
	defer fake.suspendMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeApplicationInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tview.ApplicationInterface = new(FakeApplicationInterface)
